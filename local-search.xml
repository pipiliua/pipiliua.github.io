<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>清华大学操作系统</title>
    <link href="/2023/08/24/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/24/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="清华大学操作系统"><a href="#清华大学操作系统" class="headerlink" title="@清华大学操作系统"></a>@清华大学操作系统</h1><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h5 id="OS功能"><a href="#OS功能" class="headerlink" title="OS功能"></a>OS功能</h5><ul><li>硬件抽象</li><li>硬件多路复用</li><li>隔离</li><li>共享</li><li>安全</li><li>高性能</li><li>并发</li></ul><h5 id="内核区别"><a href="#内核区别" class="headerlink" title="内核区别"></a>内核区别</h5><h6 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h6><ul><li>把功能比文件系统，内存管理等集中在内核空间，这样子可以获得更好的性能（减少内核用户空间切换次数），但是同时也会导致bug，比较难维护，常见的XV6就是宏内核</li></ul><h6 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h6><ul><li>在内核中只维最基本的功能，比如IPC，文件系统放到用户空间，但是如何获得高性能是一个问题，用户程序&gt;IPC&gt;FS;FS结果&gt;IPC&gt;用户程序；这样子相比之下，微内核实现进程间交互就多了一次的内核空间转换</li></ul><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ul><li>ls程序首先执行ecall，加上参数，控制权转移到内核，然后经过内核中的systemcall，去调用内核中的ls程序，最终完成系统调用。在内核执行指令的整个过程，内核可以随时监控指令的运行，确保指令的不合法等</li><li>系统调用可以看作是内核空间和用户空间之间的通信机制</li></ul><h5 id="OS启动过程"><a href="#OS启动过程" class="headerlink" title="OS启动过程"></a>OS启动过程</h5><p><img src="/../post_imgs/MIT6.S081/image-20230804165258732.png" alt="image-20230804165258732"></p><ul><li><img src="/../post_imgs/MIT6.S081/image-20230804165636678.png" alt="image-20230804165636678"></li></ul><h5 id="OS与设备程序交互"><a href="#OS与设备程序交互" class="headerlink" title="OS与设备程序交互"></a>OS与设备程序交互</h5><p><img src="/../post_imgs/MIT6.S081/image-20230804165904243.png" alt="image-20230804165904243"></p><h6 id="面向外设"><a href="#面向外设" class="headerlink" title="面向外设"></a>面向外设</h6><ul><li>IO和中断</li></ul><h6 id="面向程序"><a href="#面向程序" class="headerlink" title="面向程序"></a>面向程序</h6><ul><li><p>系统调用和异常</p><p>  <img src="/../post_imgs/MIT6.S081/image-20230804170502490.png" alt="image-20230804170502490"></p></li></ul><h6 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230804171728933.png" alt="image-20230804171728933"></li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h5 id="内存分层"><a href="#内存分层" class="headerlink" title="内存分层"></a>内存分层</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/../post_imgs/MIT6.S081/image-20230804173117563.png" alt="image-20230804173117563"></h5><h5 id="内存需要实现的的功能"><a href="#内存需要实现的的功能" class="headerlink" title="内存需要实现的的功能"></a>内存需要实现的的功能</h5><ul><li>抽象，用户程序不在乎内存具体</li><li>隔离，程序不干扰</li><li>共享，程序之间的沟通</li><li>虚拟化，实现内存和硬盘的交换，获得更大的内存，会程序无感</li></ul><h5 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h5><ul><li>最先分配，按地址排序查找，第一个满足的就分配空间块<ul><li>会导致外部碎片</li></ul></li><li>最佳分配，按排序从小到大查找<ul><li>导致外部碎片，但是产生影响最小</li><li>需要进行大小先排序</li></ul></li><li>最差分配，根据大小排序，选择最大的分配</li></ul><h6 id="碎片解决"><a href="#碎片解决" class="headerlink" title="碎片解决"></a>碎片解决</h6><ul><li>压缩碎片，发生在内存，需要有较多空余的内存，内存拷贝开销大以及不能在程序运行时候压缩</li><li>换入换出，发生在内存和硬盘</li></ul><h5 id="非连续内存分配：软件和硬件一起实现"><a href="#非连续内存分配：软件和硬件一起实现" class="headerlink" title="非连续内存分配：软件和硬件一起实现"></a>非连续内存分配：软件和硬件一起实现</h5><h6 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h6><ul><li>程序是由一段段代码组成的，进而把不同程序段分散到不同的物理地址</li><li><img src="/../post_imgs/MIT6.S081/image-20230805111441288.png" alt="image-20230805111441288"></li><li>映射机制</li><li><img src="/../post_imgs/MIT6.S081/image-20230805111900425.png" alt="image-20230805111900425"></li></ul><p>程序分段，段地址分为段号和偏移，首先去查询段表，得到对应段号的物理起始地址和段长限制，MMU对段地址的偏移进行计算，判断是否越界，没有越界就可以访问物理地址</p><h6 id="分页机制：用的较多"><a href="#分页机制：用的较多" class="headerlink" title="分页机制：用的较多"></a>分页机制：用的较多</h6><p><img src="/../post_imgs/MIT6.S081/image-20230805112344620.png" alt="image-20230805112344620"></p><ul><li><img src="/../post_imgs/MIT6.S081/image-20230805120618255.png" alt="image-20230805120618255"></li><li>物理分帧，逻辑分页，帧大小和页大小对应，页号和帧号大小不一定对应，页号查页表找到帧号，然后进行计算加上偏移，得到物理地址</li><li>为什么页的大小都是2*n：因为2的N次幂方计算，在硬件上实现地址转换</li></ul><h6 id="页表优化"><a href="#页表优化" class="headerlink" title="页表优化"></a>页表优化</h6><ul><li><p>&#x3D;&#x3D;快表缓存&#x3D;&#x3D;：CPU内部有个MMU内存管理单元，MMU维护了一个TLB，缓存最近访问的页帧转换项，这样子先去TLB，可以减少内存访问次数</p></li><li><p>根据程序局部性原理，程序在执行过程中访问的内存位置或者临近位置被再次访问的可能性很大，我们可以把近期访问的页表项缓存</p></li><li><p>&#x3D;&#x3D;多级页表&#x3D;&#x3D;</p></li></ul><p><img src="/../post_imgs/MIT6.S081/image-20230805144410752.png" alt="image-20230805144410752"></p><h6 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h6><ul><li>通过页帧号找到逻辑页号，和物理内存关联<ul><li>缺点，要找到对应的页号，需要进行遍历寄存器</li></ul></li></ul><h6 id="段页存储"><a href="#段页存储" class="headerlink" title="段页存储"></a>段页存储</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230805150006286.png" alt="image-20230805150006286"></li><li>方便实现共享内存<ul><li>&#x3D;&#x3D;通过指向相同的页表，实现不同段之间的共享&#x3D;&#x3D;</li></ul></li></ul><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><h6 id="为什么需要虚拟内存"><a href="#为什么需要虚拟内存" class="headerlink" title="为什么需要虚拟内存"></a>为什么需要虚拟内存</h6><ul><li>内存不够使用，成本就高</li></ul><h6 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h6><ul><li>把没有相互调用的模块放到同一个分区，这样子他们就可以分时共享内存</li></ul><h6 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230806110311583.png" alt="image-20230806110311583"></li></ul><h6 id="覆盖和交换的区别"><a href="#覆盖和交换的区别" class="headerlink" title="覆盖和交换的区别"></a>覆盖和交换的区别</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230806110430762.png" alt="image-20230806110430762"></li></ul><h6 id="虚拟内存-1"><a href="#虚拟内存-1" class="headerlink" title="虚拟内存"></a>虚拟内存</h6><ul><li>利用局部性原理，程序的指令和数据在被访问之后后面大概率还会被再次访问或者当前指令被访问其附近的指令大概率也会被访问</li><li><img src="/../post_imgs/MIT6.S081/image-20230806111005583.png" alt="image-20230806111005583"></li><li><img src="/../post_imgs/MIT6.S081/image-20230806111108173.png" alt="image-20230806111108173"></li><li><img src="/../post_imgs/MIT6.S081/image-20230806111605711.png" alt="image-20230806111605711"></li></ul><h6 id="常见页面置换算法"><a href="#常见页面置换算法" class="headerlink" title="常见页面置换算法"></a>常见页面置换算法</h6><h6 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h6><ul><li><p>&#x3D;&#x3D;最优置换算法&#x3D;&#x3D;</p><ul><li>置换在未来时间最长时间不被访问的页面</li><li><img src="/../post_imgs/MIT6.S081/image-20230806112203484.png" alt="image-20230806112203484"></li><li>无法实现，过于理想</li></ul></li><li><p>&#x3D;&#x3D;先进先出算法&#x3D;&#x3D;</p><ul><li>选择在内存中驻留时间最长的进行置换</li><li>最先进来的时间最长，置换</li><li>实现简单，可能会导致缺页次数增加</li><li><img src="/../post_imgs/MIT6.S081/image-20230806112944667.png" alt="image-20230806112944667"></li></ul></li><li><p>&#x3D;&#x3D;最长时间没有被引用（去近似最佳置算法）LRU&#x3D;&#x3D;</p><ul><li><img src="/../post_imgs/MIT6.S081/image-20230806113050691.png" alt="image-20230806113050691"></li><li><img src="/../post_imgs/MIT6.S081/image-20230806113144685.png" alt="image-20230806113144685"></li></ul><p>  <img src="/../post_imgs/MIT6.S081/image-20230806113444551.png" alt="image-20230806113444551"></p></li></ul><p><img src="/../post_imgs/MIT6.S081/image-20230806113436558.png" alt="image-20230806113436558"></p><ul><li><p>CLOCK算法（FIFO和LRU折中）</p><ul><li><img src="/../post_imgs/MIT6.S081/image-20230806123351956.png" alt="image-20230806123351956"></li><li><img src="/../post_imgs/MIT6.S081/image-20230806123408378.png" alt="image-20230806123408378"></li></ul></li><li><p><img src="/../post_imgs/MIT6.S081/image-20230806123829471.png" alt="image-20230806123829471"></p><ul><li>维护一个页面统计次数，每次访问统计➕，缺页置换选择次数最少的</li><li>有个缺点，随着时间流逝，换区域了，那些高频访问的被置换出去几率低：可以在发生时间中断的时候，那些高频次的页面次数&#x2F;2</li></ul></li><li><p><img src="/../post_imgs/MIT6.S081/image-20230806124608162.png" alt="image-20230806124608162"></p></li></ul><p>FIFO会有Belady现象</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h4><h5 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h5><ul><li>一个程序在一个数据集合上的一次动态执行过程</li><li>程序是静态的，进程是程序的动态执行；进程有用户态和和心态，程序是静态代码集合</li><li><img src="/../post_imgs/MIT6.S081/image-20230808101310155.png" alt="image-20230808101310155"></li></ul><h5 id="x3D-x3D-进程的组成-x3D-x3D"><a href="#x3D-x3D-进程的组成-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;进程的组成&#x3D;&#x3D;"></a>&#x3D;&#x3D;进程的组成&#x3D;&#x3D;</h5><ul><li>代码段</li><li>数据段</li><li>程序计数器，指向下一条要执行的指令</li><li>寄存器保存堆栈信息</li><li>使用的系统资源，比如内存，磁盘等</li></ul><h6 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h6><ul><li><p>标识信息，PID</p></li><li><p>CPU信息保存区</p><ul><li>用户可见寄存器：用户程序可使用</li><li>PC和PSW（程序状态字）</li><li>栈指针</li></ul></li><li><p>控制信息</p></li><li><p><img src="/../post_imgs/MIT6.S081/image-20230808102128784.png" alt="image-20230808102128784"></p><ul><li>调度信息，通信信息，存储信息</li></ul></li><li><p><img src="/../post_imgs/MIT6.S081/image-20230808102325865.png" alt="image-20230808102325865"></p></li></ul><h6 id="进程状态变化图片"><a href="#进程状态变化图片" class="headerlink" title="进程状态变化图片"></a>进程状态变化图片</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230808102546156.png" alt="image-20230808102546156"></li></ul><h6 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h6><ul><li><img src="/../post_imgs/MIT6.S081/image-20230808102655166.png" alt="image-20230808102655166"></li></ul><p>在挂起队列里面，根据不同的状态，用不同的队列组织</p><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><h6 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h6><ul><li>&#x3D;&#x3D;线程是进程当中的一条执行流程&#x3D;&#x3D;</li></ul><h6 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h6><ul><li>&#x3D;&#x3D;进程是资源分配的单位，是一个资源平台，线程负责代码在资源上的一次执行流程；&#x3D;&#x3D;</li><li><img src="/../post_imgs/MIT6.S081/image-20230808105411639.png" alt="image-20230808105411639"></li></ul><h6 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h6><ul><li>在用户空间，自定义实现库函数了来实现多线程，但是在内核看来，仍是单进程</li><li>好处：线程切换不需要内核介入，开销少</li><li>坏处：当线程发起系统调用而阻塞的时候，整个进程都会进入等待状态；其他进程的线程只能等待当前进程的线程主动释放CPU</li></ul><h6 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h6><ul><li><p>进程通过系统调用实现的线程机制，由内核实现线程的创建，管理和终止</p></li><li><p><img src="/../post_imgs/MIT6.S081/image-20230808111239947.png" alt="image-20230808111239947"></p></li></ul><h5 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h5><ul><li>先来先服务，对短作业不利于</li><li>短作业优先，对长作业不利于</li><li>高相应比优先<ul><li><img src="/../post_imgs/MIT6.S081/image-20230808112548674.png" alt="image-20230808112548674"></li><li>过于理想化，不知道要求服务时间是多少</li></ul></li><li>RR时间片轮转</li><li>多级反馈队列<ul><li>有多个队列从上到下，越上面，时间越短，优先级越高，先执行上面的队列</li><li><img src="/../post_imgs/MIT6.S081/image-20230808112738360.png" alt="image-20230808112738360"></li></ul></li><li></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h5 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h5><p><img src="/../post_imgs/MIT6.S081/image-20230809110127669.png" alt="image-20230809110127669"></p><h5 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h5><h6 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h6><ul><li>严格限制死锁的产生，破坏死锁四个条件之一<ul><li>互斥：只占有非共享资源</li><li>占有且等待：一次性分配资源完备或者空资源申请</li><li>非抢占：允许抢占资源</li><li>循环等待：资源排序，按照顺序申请，比如说金字塔</li></ul></li></ul><h6 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h6><ul><li>在运行过程中判断资源申请是否可能会出现死锁</li><li>银行家算法</li></ul><h6 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h6><ul><li>运行进入死锁状态，如果检测发生死锁，就进行死锁恢复。没发生就继续进行</li></ul><h3 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h3><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ul><li>直接和间接（通过内核）</li><li>阻塞和非阻塞（非阻塞就是send完毕，直接返回，不等待确认，不去看有没有完成发送和接受）</li><li>缓冲和非缓冲<ul><li>解决双方速率不匹配，提高速率</li><li>缓冲容量有限，通常是这样</li></ul></li></ul><h4 id="常用IPC实现"><a href="#常用IPC实现" class="headerlink" title="常用IPC实现"></a>常用IPC实现</h4><ul><li>信号</li><li>管道</li><li>消息队列</li><li>共享内存</li></ul><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><ul><li>进程之间通过软中断实现的的通知和处理机制</li><li>信号只是一种类型，用来做快速响应</li><li>举例子<ul><li>比如说Ctrl+C，发出软中断信号，正在执行的程序停止运行，对这种信号的处理和响应是由OS实现的</li><li>程序也可以自己实现相应的信号处理机制</li><li>有时候会忽略，比如说在登陆界面，Ctrl+C是会忽略</li></ul></li><li>过程</li><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230810112725643.png" alt="image-20230810112725643"></li></ul><p>&#x3D;&#x3D;注册针对某一信号的handles，然后通过系统调用交给OS，OS在产生相应信号之后返回；返回涉及指令的修改，比如说系统调用后的下一条执行是跳转到信号函数的入口&#x3D;&#x3D;</p><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><ul><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230810122221456.png" alt="image-20230810122221456"></li><li>管道是内核中的一块缓冲区，管道有读端和写端，ls的输出设置为管道的写端，more的输入设置为管道的读取端</li><li>0表示输入，1表示标准输出，2表示错误输出</li><li>shell是父进程，ls和more是子进程的命令，子进程结束，管跟着结束</li></ul><h6 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h6><ul><li><strong>匿名管道</strong>顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命&#x3D;&#x3D;令中的「<code>|</code>」竖线就是匿名管道&#x3D;&#x3D;，通信的数据是<strong>无格式的流并且大小受限</strong>，通信的方式是<strong>单向</strong>的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来&#x3D;&#x3D;<strong>匿名管道是只能用于存在父子关系的进程间通信</strong>，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失&#x3D;&#x3D;</li></ul><h6 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h6><ul><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230810123540258.png" alt="image-20230810123540258"></li></ul><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><ul><li>是保存在内核当中的消息链表，链表节点是自定义的消息体，比如有有自定义的数据类型，&#x3D;&#x3D;克服了管道只能传输无序字节流的缺点&#x3D;&#x3D;</li><li>&#x3D;&#x3D;消息队列克服了管道随着进程的消亡而不能使用的缺点&#x3D;&#x3D;</li><li>消息队列通信没有那么及时，因为数据的读写都要涉及用户空间到内核空间的数据拷贝过程</li></ul><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><ul><li>&#x3D;&#x3D;解决了消息队列当中的拷贝问题&#x3D;&#x3D;</li><li>分配一个共享空间，每个进程都可以访问，进程的页表项映射到同一块物理内存；但是需要自己实现互斥访问，比如说信号量实现</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><ul><li>在Linux下一切皆文件，文件由索引节点和目录项组成</li><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811163314679.png" alt="image-20230811163314679"></li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="img"></p><h6 id="硬连接和软连接的区别"><a href="#硬连接和软连接的区别" class="headerlink" title="硬连接和软连接的区别"></a>硬连接和软连接的区别</h6><ul><li>软软连接是指向新的索引节点，新的索引节点存放的是路径位置</li><li>硬连接指向的是真实的索引节点，是在磁盘上的位置</li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811163448695.png" alt="image-20230811163448695"></p><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811163627471.png" alt="image-20230811163627471"></p><h6 id="进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"><a href="#进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？" class="headerlink" title="进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？"></a>进程写文件时，进程发生了崩溃，已写入的数据会丢失吗？</h6><ul><li>进程崩溃不会，但是在持久化之前OS崩溃会丢失</li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1541c881598f554920355f0a3c5780fd.png" alt="img"></p><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811163750518.png" alt="image-20230811163750518"></p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><h6 id="键盘敲入字母时，期间发生了什么？"><a href="#键盘敲入字母时，期间发生了什么？" class="headerlink" title="键盘敲入字母时，期间发生了什么？"></a>键盘敲入字母时，期间发生了什么？</h6><ul><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%20%E7%A1%AC%E4%BB%B6%E6%80%BB%E7%BA%BF%E5%9B%BE.png" alt="CPU 的硬件架构图"></li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811164322187.png" alt="image-20230811164322187"></p><h6 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h6><ul><li><a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">点击这里</a></li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230811164756208.png" alt="image-20230811164756208"></p><ul><li><p>先来先服务算法</p></li><li><p>最短寻道时间算法</p></li><li><p>电梯算法：就是电梯扫描，比如电梯从当前位置移动到顶层，处理期间的请求，然后再从顶层移动到底层，处理期间的请求</p></li><li><p>循环扫描：电梯移到底层立马移到底层，返回途中不处理请求</p></li><li><p>LOOK算法：电梯移动到需要处理的最高楼层，不会移动到顶层，&#x3D;&#x3D;然后返回并处理&#x3D;&#x3D;</p></li><li><p>C-LOOk算法：电梯移动到需要处理的最高楼层，不会移动到顶层，&#x3D;&#x3D;然后立即返回需要处理的最低楼层，返回不做请求处理&#x3D;&#x3D;</p></li></ul><h3 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h3><h6 id="DMA流程"><a href="#DMA流程" class="headerlink" title="DMA流程"></a>DMA流程</h6><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png" alt="img"></p><ul><li>DMA流程</li><li>程序发起read系统调用，cpu从用户转化为内核态，CPU向DMA控制器发起IO请求，DMA控制器向磁盘发起IO请求，磁盘把数据放入磁盘控制器缓冲区，完成后通知DMA控制器，DMA控制器把磁盘控制器上的缓冲区数据拷贝到内核缓冲区，然后信号通知CPU，CPU把数据从内核拷贝到用户缓冲区，最后就是系统调用返回，用户态到内核切换</li><li>可以看出，一次read系统调用，四次拷贝，两次切换，十分消耗时间</li></ul><h6 id="传统文件传输"><a href="#传统文件传输" class="headerlink" title="传统文件传输"></a>传统文件传输</h6><ul><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="img"></li></ul><h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><ul><li>减少网络数据传输当中的拷贝次数</li></ul><h6 id="sendfile实现0⃣️拷贝"><a href="#sendfile实现0⃣️拷贝" class="headerlink" title="sendfile实现0⃣️拷贝"></a>sendfile实现0⃣️拷贝</h6><ul><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="img"></li><li></li></ul><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230814095919616.png" alt="image-20230814095919616"></p><h6 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h6><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230814100220802.png" alt="image-20230814100220802"></p><h5 id="IO多路复用：进程可以通过一个系统调用函数从内核中获取多个事件。"><a href="#IO多路复用：进程可以通过一个系统调用函数从内核中获取多个事件。" class="headerlink" title="IO多路复用：进程可以通过一个系统调用函数从内核中获取多个事件。"></a>IO多路复用：<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</h5><h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul><li>传统的Socket通信是一个进程或者线程处理以恶搞连接请求，当连接数增加的时候，涉及上下文切换，性能下降</li></ul><h6 id="select和poll"><a href="#select和poll" class="headerlink" title="select和poll"></a>select和poll</h6><p>- </p><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230814100518621.png" alt="image-20230814100518621"></p><h6 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h6><p><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/epoll.png" alt="img"></p><ul><li>有两种出触发器模式</li><li><img src="/../post_imgs/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20230814101355270.png" alt="image-20230814101355270"></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/08/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/07/08/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><ul><li>层次</li><li>网状</li><li>关系</li></ul><h3 id="SQL提供的能力"><a href="#SQL提供的能力" class="headerlink" title="SQL提供的能力"></a>SQL提供的能力</h3><ul><li>DDL，对表进行操作</li><li>DML，增改删</li><li>DQL，查询能力</li></ul><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><ul><li>避免和业务有关系</li><li>如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键</li></ul><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><ul><li>NOT&gt;AND&gt;OR优先级</li></ul><h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><ul><li>只取某一列</li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>order by：默认升序，加DESC降序</li></ul><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>  分页查询需要先确定每页的数量和当前页数，然后确定<code>LIMIT</code>和<code>OFFSET</code>的值</p></li><li><p><img src="/Users/gem/Library/Application%20Support/typora-user-images/image-20230706164858553.png" alt="image-20230706164858553"></p></li></ul><h4 id="聚合搜索：group-by"><a href="#聚合搜索：group-by" class="headerlink" title="聚合搜索：group by"></a>聚合搜索：group by</h4><ul><li><pre><code class="sql">  SELECT COUNT(*) num FROM students;    -- 和以下效果一样  SELECT COUNT(id) num FROM students;    -- 分组聚合  SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;  -- 我们想统计各班的男生和女生人数  SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;  -- 查出每个班级的平均分，按性别分类  SELECT class_id , gender, avg(score) from students  group by class_id,gender;          <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>#### 多表查询<br><br>- ```<span class="hljs-keyword">sql</span><br>    <span class="hljs-comment">-- 笛卡尔乘</span><br>    <span class="hljs-keyword">SELECT</span><br>        s.id sid,<br>        s.name,<br>        s.gender,<br>        s.score,<br>        c.id cid,<br>        c.name cname<br>    <span class="hljs-keyword">FROM</span> students s, classes c;<br>    <br>    <br>    <br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="连接查询（也属于多表查询的一种）"><a href="#连接查询（也属于多表查询的一种）" class="headerlink" title="连接查询（也属于多表查询的一种）"></a>连接查询（也属于多表查询的一种）</h4><ul><li><pre><code class="sql">  SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score  FROM students s  INNER JOIN classes c  ON s.class_id = c.id;    --inner join 只会给都存在的数据    <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- ![image<span class="hljs-number">-20230706170716412</span>](/Users/gem/Library/Application%<span class="hljs-number">20</span>Support/typora-<span class="hljs-keyword">user</span>-images/image<span class="hljs-number">-20230706170716412.</span>png)<br><br><br><br>### DML<br><br>#### 插入<br><br>- ```<span class="hljs-keyword">sql</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (class_id, <span class="hljs-type">name</span>, gender, score) <span class="hljs-keyword">VALUES</span><br>      (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;大宝&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">87</span>),<br>      (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;二宝&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">81</span>);<br>      <br>      <span class="hljs-comment">--  如果存在先删除再插入</span><br>      REPLACE <span class="hljs-keyword">INTO</span> students (id, class_id, <span class="hljs-type">name</span>, gender, score) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>, <span class="hljs-number">99</span>);<br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><pre><code class="sql">  DELETE FROM students WHERE id=1;  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br><span class="hljs-comment">#### 更新</span><br><br>- ```sql<br>    UPDATE students <span class="hljs-built_in">SET</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;大牛&#x27;</span>, <span class="hljs-attribute">score</span>=66 WHERE <span class="hljs-attribute">id</span>=1;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="x3D-x3D-事物-x3D-x3D"><a href="#x3D-x3D-事物-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;事物&#x3D;&#x3D;"></a>&#x3D;&#x3D;事物&#x3D;&#x3D;</h3><ul><li><pre><code class="sql">  -- 从id=1的账户给id=2的账户转账100元  -- 第一步：将id=1的A账户余额减去100  UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- 第二步：将id=2的B账户余额加上100  UPDATE accounts SET balance = balance + 100 WHERE id = 2;    -- 要求以上的操作一次性完成      <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-operator">-</span> 事务的四大特性：ACID<br><br>    <span class="hljs-operator">-</span> A：<span class="hljs-keyword">Atomic</span>，原子性，将所有<span class="hljs-keyword">SQL</span>作为原子工作单元执行，<span class="hljs-operator">=</span><span class="hljs-operator">=</span>要么全部执行，要么全部不执行<span class="hljs-operator">=</span><span class="hljs-operator">=</span>；<br>    <span class="hljs-operator">-</span> C：Consistent，一致性，事务完成后，<span class="hljs-operator">=</span><span class="hljs-operator">=</span>所有数据的状态都是一致的<span class="hljs-operator">=</span><span class="hljs-operator">=</span>，即A账户只要减去了<span class="hljs-number">100</span>，B账户则必定加上了<span class="hljs-number">100</span>；<br>    <span class="hljs-operator">-</span> I：Isolation，隔离性，<span class="hljs-operator">=</span><span class="hljs-operator">=</span>如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离<span class="hljs-operator">=</span><span class="hljs-operator">=</span>；<br>    <span class="hljs-operator">-</span> D：Duration，持久性，<span class="hljs-operator">=</span><span class="hljs-operator">=</span>即事务完成后，对数据库数据的修改被持久化存储<span class="hljs-operator">=</span><span class="hljs-operator">=</span>。<br><br><span class="hljs-operator">-</span> ```<span class="hljs-keyword">sql</span><br>    <span class="hljs-comment">-- 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务</span><br>    <span class="hljs-comment">-- 要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务：</span><br>    <br>    <span class="hljs-keyword">BEGIN</span>;<br>    <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">-- COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败</span><br>    <span class="hljs-keyword">COMMIT</span>;<br>    <br>    <span class="hljs-comment">-- 有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败</span><br>    <span class="hljs-keyword">BEGIN</span>;<br>    <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">ROLLBACK</span>;<br>    <br>    <br>    <br></code></pre></td></tr></table></figure></code></pre></li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li><img src="/Users/gem/Library/Application%20Support/typora-user-images/image-20230706171916121.png" alt="image-20230706171916121"></li></ul><h5 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h5><ul><li>Read Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）</li><li><img src="/Users/gem/Library/Application%20Support/typora-user-images/image-20230706172211023.png" alt="image-20230706172211023"></li></ul><h5 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h5><ul><li><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>  不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致</p></li><li><p><img src="/Users/gem/Library/Application%20Support/typora-user-images/image-20230706172454103.png" alt="image-20230706172454103"></p></li></ul><h5 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h5><ul><li><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>  幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了</p></li><li><p><img src="/Users/gem/Library/Application%20Support/typora-user-images/image-20230706172841910.png" alt="image-20230706172841910"></p></li></ul><h5 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h5><ul><li><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>  虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别</p></li><li><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read</p></li><li></li></ul><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="存储体系：主要分为server层和存储引擎层"><a href="#存储体系：主要分为server层和存储引擎层" class="headerlink" title="存储体系：主要分为server层和存储引擎层"></a>存储体系：主要分为server层和存储引擎层</h4><ul><li>server层：<ul><li>主要包括连接器、查询缓存、分析器、优化器、执行器等，还有一个通用的binlog日志模块</li></ul></li><li>存储引擎层<ul><li>主要负责数据的存储和读取，有比如InnoDB，MyISAM，InnoDB自带redolog日志模块，从MySQL5.5.5以后就被这设置为默认存储引擎</li></ul></li></ul><h4 id="MyISAM-和-InnoDB-有什么区别？"><a href="#MyISAM-和-InnoDB-有什么区别？" class="headerlink" title="MyISAM 和 InnoDB 有什么区别？"></a>MyISAM 和 InnoDB 有什么区别？</h4><ul><li>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁<ul><li>相对来说，行锁并发程度更高</li></ul></li><li>MyISAM 不提供事务支持<ul><li>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别</li></ul></li><li>MyISAM 不支持，而 InnoDB 支持<ul><li>但是实际上不建议使用外键，在应用层面解决</li></ul></li><li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持</li><li>InnoDB 的性能比 MyISAM 更强大</li></ul><h3 id="x3D-x3D-索引-x3D-x3D"><a href="#x3D-x3D-索引-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;索引&#x3D;&#x3D;"></a>&#x3D;&#x3D;索引&#x3D;&#x3D;</h3><h4 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h4><ul><li><strong>索引是一种用于快速查询和检索数据的&#x3D;&#x3D;数据结构&#x3D;&#x3D;，其本质可以看成是一种排序好的数据结构</strong></li><li>优缺点<ul><li>优点<ul><li>提高检索速度</li></ul></li><li>缺点<ul><li>索引会占用存储空间</li><li>对加了索引的数据进行更新的也要更新索引，降低SQL执行效率</li></ul></li><li>大多数情况下，索引是比没有索引快的</li></ul></li></ul><h4 id="索引底层数据结构了解吗？"><a href="#索引底层数据结构了解吗？" class="headerlink" title="索引底层数据结构了解吗？"></a>索引底层数据结构了解吗？</h4><ul><li>索引是在存储引擎层实现的，有B+树索引，Hash索引，MySQL支持B+树索</li></ul><h5 id="哈希索引说一下"><a href="#哈希索引说一下" class="headerlink" title="哈希索引说一下"></a>哈希索引说一下</h5><ul><li>哈希索引就是对键值对进行哈希计算，根据哈希值散列到对应的槽位上，然后存储到哈希表。通常情况下只经过一次检索就可以查询到数据，如果出现哈希碰撞，就在碰撞槽位上面实现链表，多次检索<ul><li>Hash索引的检索速率是要比B+树高的，但在不支持范围查找</li></ul></li></ul><h5 id="B-树索引说一下"><a href="#B-树索引说一下" class="headerlink" title="B+树索引说一下"></a>B+树索引说一下</h5><ul><li>由B树演变而来，区别于B树。比如说说B&#x3D;5，那么一个节点就有4个Key，五个指针，指向五个子节点。<ul><li>所有非叶子结点存储索引，数据都存在叶子结点，然后就是在相邻叶子结点实现双向链表，提高区间遍历的能力</li></ul></li></ul><h5 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h5><ul><li><p>主键索引，默认的</p></li><li><p>唯一索引</p></li><li><p>普通索引</p></li><li><p>全文索引</p></li><li><p>在InnoDB中，索引按照存储结构可以分为</p><ul><li>聚集索引，索引和数据都存放一起，比如每个叶子结点存放的就是每一行的数据</li><li>辅助索引，索引和数据分开存放，比如叶子结点存放的是id，而不是全部的行数据</li></ul></li><li><pre><code class="sql">  select * from t_user where user_name =&quot;cat&quot;  -- 现在走辅助索引找到‘cat’，然后返回id，再根据id去走聚集索引，找到那个人的全部信息，这就叫回表查询  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>    <br><br>- ![image<span class="hljs-number">-20230715104011382</span>](../post_imgs/MySQL/image<span class="hljs-number">-20230715104011382.</span>png)<br>- <br><br>```<span class="hljs-keyword">sql</span><br><span class="hljs-comment">-- 创建索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> index_name <span class="hljs-keyword">on</span> <span class="hljs-built_in">table_name</span> <br><span class="hljs-comment">-- 查看索引</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">table_name</span><br><span class="hljs-comment">-- 删除索引</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> index_name <span class="hljs-keyword">on</span> <span class="hljs-built_in">table_name</span><br><span class="hljs-comment">-- 查看当前数据库查询还是更新频率方便优化，查询才优化</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status<br><br><span class="hljs-comment">-- 对查询进行优化</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="缓存章节"><a href="#缓存章节" class="headerlink" title="缓存章节"></a>缓存章节</h3><ul><li>缓存在8.0版本以后就移除了，不太实用<ul><li>缓存命中就直接返回</li><li>因为多了缓存，每次查询之后都要做一次缓存操作，同时缓存带来额外的开销</li></ul></li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>分类<ul><li>全局锁，在备份的时候使用，DML和DDL都被阻塞</li><li>表级锁：每次操作锁住整张表，锁定粒度大，锁冲突概率最高<ul><li>表锁<ul><li>读锁：只允许读，不会阻塞其他客户端的读，但是会阻塞其他客户端的写</li><li>写锁：当前客户端允许读写，其他客户端不允许读写，会阻塞</li></ul></li><li>元数据锁：系统自动控制，维护表元数据的一致性</li><li>意向锁<ul><li>用来避免表锁和行锁的冲突，使得在加表锁的时候不用每一行去检查是否加了行锁</li><li>意向共享锁<ul><li>与表锁读锁兼容，和写锁不兼容</li></ul></li><li>意向排他锁<ul><li>与表锁的读写锁都不兼容</li></ul></li></ul></li></ul></li><li>行级锁<ul><li>行锁：锁定单个记录的锁，针对索引加的锁</li><li>间隙锁，锁住索引记录的间隙</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁</li></ul></li></ul></li></ul><h3 id="MVCC多版本控制"><a href="#MVCC多版本控制" class="headerlink" title="MVCC多版本控制"></a>MVCC多版本控制</h3><ul><li>当前读<ul><li>读取的是记录的最新版本，会读读取的记录加锁</li></ul></li><li>快照读<ul><li>简单的select语句，不加锁，读取的可能是历史版本，是非阻塞读取</li></ul></li><li>MVCC<ul><li>对版本数据控制，维护数据的多个版本</li></ul></li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li><img src="/../post_imgs/MySQL/image-20230716100053626.png" alt="image-20230716100053626"></li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><ul><li><p>垂直方向</p><ul><li>垂直分库：以表为依据，把不同表放到多个数据库当中</li><li>垂直分表；以字段属性为依据，把字段不同属性拆分到不同表中</li><li><img src="/../post_imgs/MySQL/image-20230716100404475.png" alt="image-20230716100404475"></li></ul></li><li><p>水平方向</p><ul><li>水平分库：水平切割，数据库的数据分散的存在多个数据库里面，里面的表结构一样</li><li>水平分表：水平切表，把一个表放到多个数据库里面</li></ul></li><li><p>实现技术</p></li><li><p><img src="/../post_imgs/MySQL/image-20230716101306749.png" alt="image-20230716101306749"></p></li></ul><h6 id="执行一条select语句，期间发生了什么"><a href="#执行一条select语句，期间发生了什么" class="headerlink" title="执行一条select语句，期间发生了什么"></a>执行一条select语句，期间发生了什么</h6><ol><li>连接器<ol><li>3次TCP握手和mysql客户端连接，然后验证登陆，权限验证，后面执行语句的时候根据权限判断是否合法</li></ol></li><li>查询缓存<ol><li>首先查询缓存，没查到再去下一步。8.0以后废弃了</li></ol></li><li>解析SQL<ol><li>交给解析起去做</li></ol></li><li>执行SQL<ol><li>预处理：把*换成所有列</li><li>优化器：用explain查看，可能会有多个索引，决定使用哪个索引</li><li>执行器，把执行方案交给存储引擎</li></ol></li><li>存储引擎执行完，结果返回</li></ol><h6 id="索引分类-1"><a href="#索引分类-1" class="headerlink" title="索引分类"></a>索引分类</h6><ol><li>从数据结构看，有B+树，Hash索引</li><li>主键索引和辅助索引：辅助索引节叶子结点存放主键的值</li><li>联合索引：注意避免索引失效问题</li></ol><h6 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h6><ol><li>索引覆盖优化：把经常查询的字段做联合索引，减少回表操作</li><li>主键索引自增：避免在B+树插入的时候，涉及节点的分裂</li><li>索引设置not null</li><li>防止索引失效：比如说联合索引，左模糊会失效；在where那一行当中，or两边都要走索引</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>typora shortcut in macos</title>
    <link href="/2023/04/25/typora-shortcut-in-macos/"/>
    <url>/2023/04/25/typora-shortcut-in-macos/</url>
    
    <content type="html"><![CDATA[<h1 id="常用语法和快捷键"><a href="#常用语法和快捷键" class="headerlink" title="常用语法和快捷键"></a>常用语法和快捷键</h1><table><thead><tr><th align="left">操作</th><th>快捷键</th></tr></thead><tbody><tr><td align="left">超链接</td><td>com+K</td></tr><tr><td align="left">插入表格</td><td>opt+com+T</td></tr><tr><td align="left">标题</td><td>com++</td></tr><tr><td align="left">下划线</td><td>com+U</td></tr><tr><td align="left">加粗</td><td>com+B</td></tr><tr><td align="left">代码块</td><td>opt+com+C</td></tr><tr><td align="left">引用</td><td>opt+com+Q</td></tr><tr><td align="left">有序列表</td><td>opt+com+U</td></tr><tr><td align="left">无序列表</td><td>opt+com+O</td></tr><tr><td align="left">任务列表</td><td>opt+com+X</td></tr><tr><td align="left">斜体</td><td>com+I</td></tr><tr><td align="left">切换视图和编辑模式</td><td>com+&#x2F;</td></tr><tr><td align="left">选中一行</td><td>com+L</td></tr><tr><td align="left">注释</td><td>ctr+-</td></tr></tbody></table><p>测试一下图片是否正常插入</p><p><img src="/../post_imgs/typora-shortcut-in-macos/image-20230425225115942.png" alt="无描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>some tips for English</title>
    <link href="/2023/04/25/some-tips-for-English/"/>
    <url>/2023/04/25/some-tips-for-English/</url>
    
    <content type="html"><![CDATA[<h1 id="Words"><a href="#Words" class="headerlink" title="Words"></a>Words</h1><ul><li>Word recommendation Collins five-star rating words, we put 2-5🌟 words back, in the vocabulary can basically read most of the article</li><li>A more effective way to memorize words is to start with prefixes, roots and suffixes, click here<a href="https://www.bilibili.com/video/BV1Hi4y1Q7XN/?share_source=copy_web&vd_source=011d936f002d24c51ec8d1b3715eb659">🔗</a></li></ul><h1 id="Grammer"><a href="#Grammer" class="headerlink" title="Grammer"></a>Grammer</h1><ul><li>Sometimes it is difficult for us to understand some long and difficult sentences. The reason is not that we do not know the words, but that we do not understand the structure of the sentences. Here I recommend Tian Jing’s analysis of long difficult sentences.Here you need to find the relevant resources yourself</li></ul><h1 id="Reading"><a href="#Reading" class="headerlink" title="Reading"></a>Reading</h1><ul><li>As for me, I like to read articles from The Economist, but there is a limit to the number of times you can read articles from the Economist’s website. See this open source project for unlimited access <a href="https://github.com/iamadamdev/bypass-paywalls-chrome">🔗</a>. If you don’t have 🪜, you can read this website in the country, Coco English provides bilingual reading.<a href="http://www.kekenet.com/Article/media/economist/">🔗</a></li></ul><h1 id="About"><a href="#About" class="headerlink" title="About"></a>About</h1><ul><li>If there is an update, will be added later</li></ul>]]></content>
    
    
    <categories>
      
      <category>English share</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo搭建博客（基础版）</title>
    <link href="/2023/03/25/test/"/>
    <url>/2023/03/25/test/</url>
    
    <content type="html"><![CDATA[<h5 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h5><p>MacBook Air M1</p><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p><a href="https://hexo.io/zh-cn/index.html">hexo</a></p><p>hexo是一个博客框架，基于Node.js实现</p><p>Node.js是一个JavaScript运行时环境。你可以理解为JavaScript是一门语言，然后在Google开发的V8引擎上运行，Ryan Dahl外国小哥把它们们打包做出来一个web服务器项目，命名为Node.js。</p><p>故名思义，npm就是Node.js下面的包管理工具</p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040">Node.js了解</a></p><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><h6 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h6><p>先下载homebrew，这是macOS下面的一个包管理工具，我们可以很方便的用它来下载网上的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/bin/zsh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>执行脚本，按照要求下载即可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure><p>然后就是用brew下载git（homebrew是用brew来负责执行的）</p><h6 id="安装Node和npm"><a href="#安装Node和npm" class="headerlink" title="安装Node和npm"></a>安装Node和npm</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行命令下载node</span><br>brew install node<br><span class="hljs-comment"># 查看版本</span><br>node -v<br>npm -v<br></code></pre></td></tr></table></figure><p>尽量下新的版本，新版本会带有npm，我之前下过老的node版本，还要自己手动下载npm</p><h2 id="搭建："><a href="#搭建：" class="headerlink" title="搭建："></a>搭建：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-cli -g<br><span class="hljs-built_in">mkdir</span> blog&amp;&amp;<span class="hljs-built_in">cd</span> blog<br>hexo init<br>npm install<br>hexo server<br></code></pre></td></tr></table></figure><p>init初始化之后会出现几个文件夹</p><p>​</p><p><a href="https://hexo.io/zh-cn/docs/configuration">配置信息的说明</a></p><p>接下来我们生成一篇属于自己的post</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n <span class="hljs-string">&quot;your post name&quot;</span><br></code></pre></td></tr></table></figure><p>属于你的一篇post就建成了，你可以在其中添加相关信息，详情参照<a href="https://hexo.io/zh-cn/docs/configuration">配置信息的说明</a></p><h2 id="在本地部署"><a href="#在本地部署" class="headerlink" title="在本地部署"></a>在本地部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean&amp;&amp;hexo g&amp;&amp;hexo s<br><span class="hljs-comment"># g代表generate，生成静态文件</span><br><span class="hljs-comment"># s代表server启动</span><br><span class="hljs-comment"># 强烈建议每次启动之前都clean一下，清除缓存文件和已经生成的静态文件，避免主题等更换后不起效</span><br><br></code></pre></td></tr></table></figure><p><a href="https://hexo.io/zh-cn/docs/commands">hexo命令解释</a></p><p>浏览器本地访问即可以以看到自己的博客</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://localhost:4000/<br></code></pre></td></tr></table></figure><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>首先设置本地git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># name 即你的GitHub账号，email就是你的注册邮箱</span><br>git config --global user.name <span class="hljs-string">&quot;your name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your email&quot;</span><br><br></code></pre></td></tr></table></figure><p>然后配置密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;your email&quot;</span><br><span class="hljs-comment"># 一路回车即可以，最后输出一个路径，路径下有id_rsa.pub文件</span><br><span class="hljs-comment"># cat xxx/xxx/id_rsa.pub得到公钥</span><br></code></pre></td></tr></table></figure><p>然后GitHub右上角头像点击</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">settings&gt;SSH and GPG keys&gt;new SSH key<br>输入粘贴的公钥和给名称即可<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试是否配置成功</span><br>ssh -T git@github.com<br><br></code></pre></td></tr></table></figure><p>在GitHub上面创建一个仓库，注意仓库名字应该为</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&quot;your name&quot;.github.io<br><span class="hljs-section"># your name 就是你的GitHub名字</span><br>然后在仓库的settings&gt;Pages,修改配置，分支需要和下面的<span class="hljs-emphasis">_config.yml一致</span><br><span class="hljs-emphasis"></span><br></code></pre></td></tr></table></figure><p><img src="/../post_imgs/test/image-20230327105314699.png"></p><p>同时我们要访问的网址也是在page里面看到</p><p>修改hexo的配置文件</p><p>在创建的文件夹下面，我们初始化了，对_config.yml进行修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:xxx/xxx.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br><span class="hljs-comment"># xxx就是你的GitHub名字</span><br></code></pre></td></tr></table></figure><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><p>回到自己创建的文件夹下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean&amp;&amp; hexo g&amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>访问以下网址就可以访问到你的个人博客啦</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># xxx就是你之前设置的仓库名</span><br>https://xxx.github.io/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
